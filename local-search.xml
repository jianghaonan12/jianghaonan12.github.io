<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker安装mysql</title>
    <link href="/2023/07/04/docker%E5%AE%89%E8%A3%85mysql/"/>
    <url>/2023/07/04/docker%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<p><strong>1.docker拉取mysql镜像</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker pull mysql:8.0.29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处我以8.0.29版本为例</p><p><strong>2.查看镜像是否成功拉取到mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>3.将mysql配置文件复制到容器外，并运行mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 简单运行容器，为了拷贝配置文件docker run --name mysql --hostname&#x3D;root -d mysql:8.0.29# 拷贝MySQL配置文件docker container cp mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F; &#x2F;docker&#x2F;mysql&#x2F;conf# 删除容器docker rm -f mysql# 运行容器docker run --name mysql \--restart&#x3D;always -p 3306:3306 \-v &#x2F;docker&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \-v &#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-v &#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F; \-e TZ&#x3D;&quot;Asia&#x2F;Shanghai&quot; \-e MYSQL_ROOT_PASSWORD&#x3D;root \--hostname&#x3D;root -d mysql:8.0.29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时mysql已经成功启动，接下来进入mysql容器登录一下mysql</p><p><strong>4.进入mysql容器</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker exec -it mysql &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>5.登录mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这一行命令运行完成之后，会让你输入密码，输入你配置的密码即可登录成功</p><p><strong>6.查看所有的数据库</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>7.选择要进入的数据库</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">use test;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处我选择的是test数据库</p><p><strong>8.创建一张表</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE employees (   -&gt;     id INT PRIMARY KEY,   -&gt;     name VARCHAR(50) NOT NULL,   -&gt;     age INT,   -&gt;     salary DECIMAL(10, 2)   -&gt; );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>创建了一张名为employees的表</p><p><strong>9.展示表结构</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">desc employees;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq在idea中的实现</title>
    <link href="/2023/07/03/rabbitmq%E5%9C%A8idea%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/03/rabbitmq%E5%9C%A8idea%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>1.导入坐标</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>2.在yml文件中配置rabbitmq相关配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">spring:  rabbitmq:    port: 5672    username: rabbitmq    password: rabbitmq    host: 192.168.221.128    virtual-host: &#x2F;    publisher-confirm-type: correlated    publisher-returns: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后两个不是必须的，这俩是开启消息确认和消息回退的配置。username和password是你自己的。host也是。</p><p>3.写一个配置类，来配置rabbitmq的交换机和队列之间的关系</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class Config &#123;    public static final String EXCHANGE &#x3D; &quot;order.insert&quot;;    public static final String QUEUE_ONE &#x3D; &quot;queue.one&quot;;    public static final String QUEUE_TWO &#x3D; &quot;queue.two&quot;;    public static final String KEY_ONE &#x3D; &quot;key.one&quot;;    public static final String KEY_TWO &#x3D; &quot;key.two&quot;;    @Bean    public TopicExchange createExchange() &#123;        return ExchangeBuilder.topicExchange(EXCHANGE).durable(true).build();    &#125;    @Bean    public Queue createQueueOne() &#123;        return QueueBuilder.durable(QUEUE_ONE).build();    &#125;    @Bean    public Queue createQueueTwo() &#123;        return QueueBuilder.durable(QUEUE_TWO).build();    &#125;    @Bean    public Binding bindingQueueOne() &#123;        return BindingBuilder.bind(createQueueOne()).to(createExchange()).with(KEY_ONE);    &#125;    @Bean    public Binding bindingQueueTwo() &#123;        return BindingBuilder.bind(createQueueTwo()).to(createExchange()).with(KEY_TWO);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以上配置类的意思是声明了一个交换机和两个队列，两个key。一个交换机对应两个队列，就需要两个key来进行绑定。</p><p>4.声明一个生产者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@SpringBootTest@Slf4jpublic class Product &#123;    @Autowired    private  RabbitTemplate rabbitTemplate;    @Autowired    private ApplicationEventPublisher publisher;    @Test   public void conver()&#123;&#x2F;&#x2F;     rabbitTemplate.convertAndSend(Config.EXCHANGE,Config.KEY_ONE,5566); &#x2F;&#x2F;这个是正确的交换机，能够成功发送消息       rabbitTemplate.convertAndSend(&quot;1&quot;,Config.KEY_ONE,5566);  &#x2F;&#x2F;这个是用来模拟交换机错误的       publisher.publishEvent(new Event(5566));  &#x2F;&#x2F;事件的发布   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>5.声明一个消费者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@SpringBootTestpublic class Consumer &#123;    @RabbitListener(queues &#x3D; Config.QUEUE_ONE)    @Test    public void listen(Integer mes)&#123;        System.out.println(mes);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时已经可以完成消息的发送和监听了，下面的配置是消息确认和消息回退的配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Component@Slf4j@Datapublic class MQCallback implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;    @Autowired    private RabbitTemplate rabbitTemplate;    private Event data;    @PostConstruct       &#x2F;&#x2F;此注解表明在rabbitTemplate注入之后，紧接着对rabbitTemplate进行一些初始化操作    public void init()&#123;        &#x2F;&#x2F;注入接口实现        rabbitTemplate.setConfirmCallback(this::confirm);           &#x2F;&#x2F;注入接口实现        rabbitTemplate.setReturnsCallback(this::returnedMessage);    &#125;    @TransactionalEventListener(phase &#x3D; TransactionPhase.AFTER_COMPLETION,fallbackExecution &#x3D; true)    public void listen(Event data)&#123;  &#x2F;&#x2F;此注解所标记的方法用来监听到发布的事件，就是生产者那里publisher所执行的方法    this.data &#x3D; data;    &#125;    @Override    public void confirm(CorrelationData correlationData, boolean ack, String errorMes) &#123;        CorrelationData correlationData1 &#x3D; Optional.ofNullable(correlationData).orElse(new CorrelationData());        if (ack)&#123;            log.info(&quot;发送成功&quot;,correlationData1.getId());        &#125;else &#123;           log.info(&quot;交换机未收到&#123;&#125;,发送失败原因&#123;&#125;&quot;,correlationData1.getId(),errorMes);            rabbitTemplate.convertAndSend(Config.EXCHANGE,Config.KEY_ONE,data.getData());        &#125;    &#125;    @Override    public void returnedMessage(ReturnedMessage returnedMessage) &#123;       log.error(&quot;回退消息&#123;&#125;&quot;,returnedMessage);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>confirm</strong>方法是交换机发生错误时的回调方法，以下是它所包含的三个参数：（刚重写完方法的参数名字应该不是我这个，可以自己修改，所代表的意思是一样的）</p><p>correlationData表示发送的消息的一些相关信息，包括消息的唯一ID，详细的可以点进去这个类进行查看</p><p>ack表示消息是否发送成功，true为成功，false为失败</p><p>errorMes表示错误的信息</p><p><strong>returnedMessage</strong>方法是队列发生错误时的回调方法，参数returnedMessage就是错误信息</p><p>6.还有一个事件类，这个和rabbitmq无关，只是用来监听生产者发送的消息</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Getter@Setterpublic class Event&lt;T&gt; extends ApplicationEvent &#123;    private T data;    public Event(T data) &#123;        super(data);        this.data &#x3D; data;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装hexo</title>
    <link href="/2023/07/02/%E5%AE%89%E8%A3%85hexo/"/>
    <url>/2023/07/02/%E5%AE%89%E8%A3%85hexo/</url>
    
    <content type="html"><![CDATA[<p>要安装Hexo，您可以按照以下步骤进行操作：</p><ol><li><p><strong>安装 Node.js：</strong> Hexo 是基于 Node.js 的静态网站生成器，因此首先需要安装 Node.js。您可以从 Node.js 官方网站（<a href="https://nodejs.org/">https://nodejs.org</a>）下载适合您操作系统的版本，并按照安装向导进行安装。</p></li><li><p><strong>安装 Hexo：</strong> 在安装完 Node.js 后，打开命令行工具（终端或命令提示符），运行以下命令来全局安装 Hexo：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>创建 Hexo 网站：</strong> 创建一个新的 Hexo 网站，进入您想存储 Hexo 文件的目录，然后运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo init my-blog cd my-blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>安装依赖项：</strong> 进入 Hexo 网站目录后，运行以下命令来安装所需的依赖项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>推荐使用Fluid主题：</strong><br><strong>方式一：</strong><br>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--save</span> hexo-theme-fluid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>执行完此命令，在<strong>node_modules</strong>文件夹下有一个<strong>hexo-theme-fluid</strong>文件夹，<br>然后在博客目录下创建 <code>_config.fluid.yml</code>，将<strong>hexo-theme-fluid</strong>中的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。<br><strong>方式二：</strong><br>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p></li><li><p><strong>编写文章：</strong> 使用以下命令创建一篇新的文章：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;My First Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这将在 <code>source/_posts</code> 目录下创建一个 Markdown 文件，在其中编写您的文章。</p></li><li><p><strong>预览网站：</strong> 在编辑完文章后，可以使用以下命令在本地预览 Hexo 网站：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>关于页面的详细配置可以看<a href="">https://hexo.fluid-dev.com/docs/guide</a></p></li><li><p>hexo的官网是<a href="https://hexo.io/zh-cn/">Hexo</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo部署到github</title>
    <link href="/2023/07/02/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2023/07/02/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<p><strong>Hexo Theme Fluid的官方网址：</strong><a href="">https://hexo.fluid-dev.com/</a></p><p>打开自己博客文件夹的根目录下的配置文件 _config.yml，翻到最后，进行如下修改即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https:&#x2F;&#x2F;github自己的token@github.com&#x2F;github的username&#x2F;github的username.github.io  branch: gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>&lt;github的username&gt;.github.io是你的github仓库。例如：zhangsan.github.io（github.io也是仓库名的一部分）</strong></p><p><strong>新的 token 设置网址：<a href="https://github.com/settings/tokens">Personal Access Tokens (Classic) (github.com)</a></strong></p><p>修改完配置文件 _config.yml 并保存后，回到 gitbash</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后进行部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>浏览 <code>&lt;github的username&gt;.github.io</code> 检查你的网站能否运作。例如：zhangsan.github.io</p><p>地址栏输入之后就能看到自己的博客了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker安装nginx</title>
    <link href="/2023/07/02/docker%E5%AE%89%E8%A3%85nginx/"/>
    <url>/2023/07/02/docker%E5%AE%89%E8%A3%85nginx/</url>
    
    <content type="html"><![CDATA[<h3 id="1-拉取-nginx-镜像"><a href="#1-拉取-nginx-镜像" class="headerlink" title="1. 拉取 nginx 镜像"></a>1. 拉取 nginx 镜像</h3><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none"># 拉取 nginx 镜像docker pull nginx           # 不加版本号默认下载 latest 版本，即 docker pull nginx:latest# 查看镜像docker images</code></pre></div></figure><h3 id="2-运行镜像（使用-nginx-latest-镜像创建容器）"><a href="#2-运行镜像（使用-nginx-latest-镜像创建容器）" class="headerlink" title="2. 运行镜像（使用 nginx:latest 镜像创建容器）"></a>2. 运行镜像（使用 nginx:latest 镜像创建容器）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;docker&#x2F;nginx&#x2F;conf # nginx 存放配置文件的目录 mkdir -p &#x2F;docker&#x2F;nginx&#x2F;logs # nginx 存放日志的目录 mkdir -p &#x2F;docker&#x2F;nginx&#x2F;html # nginx 启动网站目录（存放静态文件的目录）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>然后将 nginx 镜像中的部分文件拷贝到宿主机的挂载目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 1. 先使用 nginx 镜像创建 nginx 容器，将文件拷贝出来先 docker run --name nginx -d -p 80:80 nginx # 2. 将容器中的 nginx.conf 文件拷贝到宿主机中 docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf # 3. 将容器中 conf.d 文件夹（包括里面的文件）拷贝到宿主机中 docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d # 4. 将容器中的 html 文件夹拷贝到宿主机中 docker cp nginx:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;docker&#x2F;nginx&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>停止刚刚运行的 nginx 容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 停止 nginx 容器 docker stop nginx # 删除 nginx 容器 docker rm nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>重新使用 nginx 镜像创建 nginx 容器，并挂载容器数据卷到宿主机目录中<br>    # 要执行的命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker run -p 80:80 --name nginx \-v &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \-v &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \-v &#x2F;docker&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \-d \--restart&#x3D;always \nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命令说明：</p><ul><li><code>-p 80:80</code> 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li><code>--name nginx</code> 命名启动的容器名字为 nginx</li><li><code>-v</code> 载文件或目录：前面是宿主机部分，后面是容器部分</li><li><code>-d</code> 表示后台启动容器</li><li><code>--restart=always</code> 重启模式，每次启动 docker 都会自动重启 nginx 容器。</li><li><code>nginx:latest</code> 表示使用该镜像创建容器</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
