<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>本地配置nacos</title>
    <link href="/2023/07/22/%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AEnacos/"/>
    <url>/2023/07/22/%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AEnacos/</url>
    
    <content type="html"><![CDATA[<p><strong>1.在nacos的conf目录下的application.properties中添加mysql的配置</strong><img src="C:/Users/jhn/Desktop/202372218515.jpg"></p><p><img src="file:///C:/Users/jhn/Desktop/202372218515.jpg" title="nacos配置mysql"></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#*************** Config Module Related Configurations ***************#### If use MySQL as datasource: spring.datasource.platform&#x3D;mysql### Count of DB: db.num&#x3D;1### Connect URL of DB: db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.221.128:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC db.user.0&#x3D;root db.password.0&#x3D;root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>原本里面就有，放开就行，去掉#号</p><p><strong>2.创建一个数据库，名为nacos_config，然后执行以下sql：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * Copyright 1999-2018 Alibaba Group Holding Ltd. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *&#x2F;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) DEFAULT NULL,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;c_desc&#96; varchar(256) DEFAULT NULL,  &#96;c_use&#96; varchar(64) DEFAULT NULL,  &#96;effect&#96; varchar(64) DEFAULT NULL,  &#96;type&#96; varchar(64) DEFAULT NULL,  &#96;c_schema&#96; text,  &#96;encrypted_data_key&#96; text NOT NULL COMMENT &#39;秘钥&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_aggr&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;datum_id&#96; varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;内容&#39;,  &#96;gmt_modified&#96; datetime NOT NULL COMMENT &#39;修改时间&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_beta&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;beta_ips&#96; varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;encrypted_data_key&#96; text NOT NULL COMMENT &#39;秘钥&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_info_tag&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tag_id&#96; varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL COMMENT &#39;content&#39;,  &#96;md5&#96; varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  &#96;src_user&#96; text COMMENT &#39;source user&#39;,  &#96;src_ip&#96; varchar(20) DEFAULT NULL COMMENT &#39;source ip&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;config_tags_relation&#96; (  &#96;id&#96; bigint(20) NOT NULL COMMENT &#39;id&#39;,  &#96;tag_name&#96; varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,  &#96;tag_type&#96; varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,  &#96;data_id&#96; varchar(255) NOT NULL COMMENT &#39;data_id&#39;,  &#96;group_id&#96; varchar(128) NOT NULL COMMENT &#39;group_id&#39;,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;nid&#96; bigint(20) NOT NULL AUTO_INCREMENT,  PRIMARY KEY (&#96;nid&#96;),  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;group_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;group_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;his_config_info&#96; (  &#96;id&#96; bigint(64) unsigned NOT NULL,  &#96;nid&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,  &#96;data_id&#96; varchar(255) NOT NULL,  &#96;group_id&#96; varchar(128) NOT NULL,  &#96;app_name&#96; varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,  &#96;content&#96; longtext NOT NULL,  &#96;md5&#96; varchar(32) DEFAULT NULL,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,  &#96;src_user&#96; text,  &#96;src_ip&#96; varchar(20) DEFAULT NULL,  &#96;op_type&#96; char(10) DEFAULT NULL,  &#96;tenant_id&#96; varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,  &#96;encrypted_data_key&#96; text NOT NULL COMMENT &#39;秘钥&#39;,  PRIMARY KEY (&#96;nid&#96;),  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),  KEY &#96;idx_did&#96; (&#96;data_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;&#x2F;******************************************&#x2F;&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;&#x2F;******************************************&#x2F;CREATE TABLE &#96;tenant_capacity&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;tenant_id&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,  &#96;quota&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,  &#96;usage&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,  &#96;max_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_aggr_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,  &#96;max_aggr_size&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,  &#96;max_history_count&#96; int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,  &#96;gmt_create&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; datetime NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;CREATE TABLE &#96;tenant_info&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,  &#96;kp&#96; varchar(128) NOT NULL COMMENT &#39;kp&#39;,  &#96;tenant_id&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,  &#96;tenant_name&#96; varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,  &#96;tenant_desc&#96; varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,  &#96;create_source&#96; varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,  &#96;gmt_modified&#96; bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;CREATE TABLE users (username varchar(50) NOT NULL PRIMARY KEY,password varchar(500) NOT NULL,enabled boolean NOT NULL);CREATE TABLE roles (username varchar(50) NOT NULL,role varchar(50) NOT NULL,constraint uk_username_role UNIQUE (username,role));CREATE TABLE permissions (    role varchar(50) NOT NULL,    resource varchar(512) NOT NULL,    action varchar(8) NOT NULL,    constraint uk_role_permission UNIQUE (role,resource,action));INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>3.运行nacos之后，新建配置文件，就会保存到mysql中</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用redis作为springcache缓存</title>
    <link href="/2023/07/08/%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BAspringcache%E7%BC%93%E5%AD%98/"/>
    <url>/2023/07/08/%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BAspringcache%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p><strong>Spring Cache常用注解</strong></p><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能</td></tr><tr><td align="center">@Cacheable</td><td align="center">使用该注解的方法在执行前，先将方法的参数作为 key 去缓存中查找，如果缓存中存在该 key，则直接返回对应的结果；否则，执行该方法，并将结果存储到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">使用该注解的方法总是会执行，并将其结果存储到缓存中。这个注解常用于更新缓存。</td></tr><tr><td align="center">@CacheEvict</td><td align="center">使用该注解的方法会从缓存中移除指定的数据</td></tr><tr><td align="center">@Caching</td><td align="center">这个注解用于组合以上三种注解，可以在一个方法中同时使用多个缓存注解。</td></tr></tbody></table><p><strong>1.导入依赖</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- Spring Cache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!-- Redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>2.配置yml文件</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">server:  port: 8080spring:  redis:    host: 192.168.221.128    port: 6380    database: 0  cache:    type: redis    redis:      time-to-live: 1800000      cache-null-values: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>3.编写使用redis作为缓存的配置类</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@EnableConfigurationProperties(CacheProperties.class) &#x2F;&#x2F;将配置文件对应的配置读到此类对应的属性上@Configuration@EnableCachingpublic class RedisConfig &#123;    @Bean    RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties)&#123;        RedisCacheConfiguration config  &#x3D; RedisCacheConfiguration.defaultCacheConfig();        &#x2F;&#x2F;设置key用string类型保存，value用json格式保存        config &#x3D; config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));        config &#x3D; config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericFastJsonRedisSerializer()));        CacheProperties.Redis redisProperties &#x3D; cacheProperties.getRedis();        &#x2F;&#x2F;使配置文件中所有的配置都生效        if (redisProperties.getTimeToLive() !&#x3D; null) &#123;            config &#x3D; config.entryTtl(redisProperties.getTimeToLive());        &#125;        if (redisProperties.getKeyPrefix() !&#x3D; null) &#123;            config &#x3D; config.prefixKeysWith(redisProperties.getKeyPrefix());        &#125;        if (!redisProperties.isCacheNullValues()) &#123;            config &#x3D; config.disableCachingNullValues();        &#125;        if (!redisProperties.isUseKeyPrefix()) &#123;            config &#x3D; config.disableKeyPrefix();        &#125;        return config;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>4.在方法上使用相应的注解</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@RestController@RequestMapping(&quot;&#x2F;user&quot;)public class Controller &#123;    @GetMapping(&quot;&#x2F;demo&quot;)    @Cacheable(cacheNames &#x3D; &quot;user&quot;, key &#x3D; &quot;#userInfo.uid&quot;)    public UserInfo test(@RequestBody UserInfo userInfo) &#123;        return userInfo;    &#125;    @CachePut(cacheNames &#x3D; &quot;user&quot;, key &#x3D; &quot;#userInfo.uid&quot;)    @DeleteMapping(&quot;&#x2F;demo&quot;)    public UserInfo delete(@RequestBody UserInfo userInfo) &#123;        userInfo.setMessage(&quot;我是更新后的&quot;);        return userInfo;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用websocket进行消息发送</title>
    <link href="/2023/07/06/%E4%BD%BF%E7%94%A8websocket%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <url>/2023/07/06/%E4%BD%BF%E7%94%A8websocket%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</url>
    
    <content type="html"><![CDATA[<p><strong>1.导入maven坐标</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-websocket&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>2.创建一个配置类</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class WebsocketConfig &#123;    @Bean    public ServerEndpointExporter serverEndpointExporter()&#123;        return new ServerEndpointExporter();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>3.编写websocket的处理类，相当于HTTP请求中的controller</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Component@Slf4j@ServerEndpoint(&quot;&#x2F;api&#x2F;pushMessage&#x2F;&#123;userId&#125;&quot;)public class WebsocketController &#123;    &#x2F;**     * 记录当前的在线连接数     *&#x2F;    private static final AtomicInteger onlineCount &#x3D; new AtomicInteger(0);    &#x2F;**     * 用来存放每个客户端对应的webSocket对象     *&#x2F;    private static final ConcurrentHashMap&lt;String, WebsocketController&gt; webSocketMap &#x3D; new ConcurrentHashMap&lt;&gt;();    &#x2F;**     * 与某个客户端的连接会话，需要通过它来给客户端发送数据     *&#x2F;    private Session session;    &#x2F;**     * 客户端的标示     *&#x2F;    private String userId;    @OnOpen    public void onOpen(Session session, @PathParam(&quot;userId&quot;) String userId)&#123;        this.session &#x3D; session;        this.userId &#x3D; userId;        if (webSocketMap.containsKey(userId))&#123;            webSocketMap.remove(userId);            webSocketMap.put(userId,this);        &#125;else &#123;            webSocketMap.put(userId,this);            onlineCount.incrementAndGet();        &#125;        log.info(&quot;用户连接:&quot;+userId+&quot;，当前在线人数为:&quot;+onlineCount);        sendMessage(&quot;连接成功&quot;);    &#125;    @OnClose    public void onClose()&#123;        if (webSocketMap.containsKey(userId))&#123;            webSocketMap.remove(userId);            onlineCount.decrementAndGet();        &#125;        log.info(&quot;用户退出:&quot;+userId+&quot;，当前在线人数为：&quot;+ onlineCount);    &#125;    @OnMessage    public void onMessage(String message, Session session)&#123;        UserInfo userInfo &#x3D; JSONUtil.toBean(message, UserInfo.class);        Object message1 &#x3D; userInfo.getMessage();        log.info(&quot;用户消息:&quot; + userId + &quot;,报文:&quot; + message1);        String uid &#x3D; userInfo.getUid();        if (StrUtil.isNotBlank(uid) &amp;&amp; webSocketMap.containsKey(uid))&#123;            webSocketMap.get(uid).sendMessage(message1.toString());        &#125;else &#123;            log.error(&quot;请求的userId:&quot; + uid + &quot;不在该服务器上&quot;);        &#125;    &#125;    @OnError    public void onError(Session session, Throwable error) &#123;        log.error(&quot;用户错误:&quot; + this.userId + &quot;,原因:&quot; + error.getMessage());        error.printStackTrace();    &#125;    public void sendMessage(String message)&#123;        session.getAsyncRemote().sendText(message);    &#125;    public static void sendInfo(String message, String userId) &#123;        log.info(&quot;发送消息到:&quot; + userId + &quot;，报文:&quot; + message);        if (StrUtil.isNotBlank(userId) &amp;&amp; webSocketMap.containsKey(userId)) &#123;            webSocketMap.get(userId).sendMessage(message);        &#125; else &#123;            log.error(&quot;用户&quot; + userId + &quot;,不在线！&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>4.创建一个UserInfo类，用来接收发送过来的消息体</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Datapublic class UserInfo&lt;T&gt; &#123;    private String uid;    private T message;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在处理类里有用到</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker安装mysql</title>
    <link href="/2023/07/04/docker%E5%AE%89%E8%A3%85mysql/"/>
    <url>/2023/07/04/docker%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<p><strong>1.docker拉取mysql镜像</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker pull mysql:8.0.29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处我以8.0.29版本为例</p><p><strong>2.查看镜像是否成功拉取到mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>3.将mysql配置文件复制到容器外，并运行mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 简单运行容器，为了拷贝配置文件docker run --name mysql --hostname&#x3D;root -d mysql:8.0.29# 拷贝MySQL配置文件docker container cp mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F; &#x2F;docker&#x2F;mysql&#x2F;conf# 删除容器docker rm -f mysql# 运行容器docker run --name mysql \--restart&#x3D;always -p 3306:3306 \-v &#x2F;docker&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \-v &#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-v &#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F; \-e TZ&#x3D;&quot;Asia&#x2F;Shanghai&quot; \-e MYSQL_ROOT_PASSWORD&#x3D;root \--hostname&#x3D;root -d mysql:8.0.29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时mysql已经成功启动，接下来进入mysql容器登录一下mysql</p><p><strong>4.进入mysql容器</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker exec -it mysql &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>5.登录mysql</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这一行命令运行完成之后，会让你输入密码，输入你配置的密码即可登录成功</p><p><strong>6.查看所有的数据库</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>7.选择要进入的数据库</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">use test;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处我选择的是test数据库</p><p><strong>8.创建一张表</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE employees (   -&gt;     id INT PRIMARY KEY,   -&gt;     name VARCHAR(50) NOT NULL,   -&gt;     age INT,   -&gt;     salary DECIMAL(10, 2)   -&gt; );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>创建了一张名为employees的表</p><p><strong>9.展示表结构</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">desc employees;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq在idea中的实现</title>
    <link href="/2023/07/03/rabbitmq%E5%9C%A8idea%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/03/rabbitmq%E5%9C%A8idea%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>1.导入坐标</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>2.在yml文件中配置rabbitmq相关配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">spring:  rabbitmq:    port: 5672    username: rabbitmq    password: rabbitmq    host: 192.168.221.128    virtual-host: &#x2F;    publisher-confirm-type: correlated    publisher-returns: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后两个不是必须的，这俩是开启消息确认和消息回退的配置。username和password是你自己的。host也是。</p><p>3.写一个配置类，来配置rabbitmq的交换机和队列之间的关系</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class Config &#123;    public static final String EXCHANGE &#x3D; &quot;order.insert&quot;;    public static final String QUEUE_ONE &#x3D; &quot;queue.one&quot;;    public static final String QUEUE_TWO &#x3D; &quot;queue.two&quot;;    public static final String KEY_ONE &#x3D; &quot;key.one&quot;;    public static final String KEY_TWO &#x3D; &quot;key.two&quot;;    @Bean    public TopicExchange createExchange() &#123;        return ExchangeBuilder.topicExchange(EXCHANGE).durable(true).build();    &#125;    @Bean    public Queue createQueueOne() &#123;        return QueueBuilder.durable(QUEUE_ONE).build();    &#125;    @Bean    public Queue createQueueTwo() &#123;        return QueueBuilder.durable(QUEUE_TWO).build();    &#125;    @Bean    public Binding bindingQueueOne() &#123;        return BindingBuilder.bind(createQueueOne()).to(createExchange()).with(KEY_ONE);    &#125;    @Bean    public Binding bindingQueueTwo() &#123;        return BindingBuilder.bind(createQueueTwo()).to(createExchange()).with(KEY_TWO);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以上配置类的意思是声明了一个交换机和两个队列，两个key。一个交换机对应两个队列，就需要两个key来进行绑定。</p><p>4.声明一个生产者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@SpringBootTest@Slf4jpublic class Product &#123;    @Autowired    private  RabbitTemplate rabbitTemplate;    @Autowired    private ApplicationEventPublisher publisher;    @Test   public void conver()&#123;&#x2F;&#x2F;     rabbitTemplate.convertAndSend(Config.EXCHANGE,Config.KEY_ONE,5566); &#x2F;&#x2F;这个是正确的交换机，能够成功发送消息       rabbitTemplate.convertAndSend(&quot;1&quot;,Config.KEY_ONE,5566);  &#x2F;&#x2F;这个是用来模拟交换机错误的       publisher.publishEvent(new Event(5566));  &#x2F;&#x2F;事件的发布   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>5.声明一个消费者</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@SpringBootTestpublic class Consumer &#123;    @RabbitListener(queues &#x3D; Config.QUEUE_ONE)    @Test    public void listen(Integer mes)&#123;        System.out.println(mes);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时已经可以完成消息的发送和监听了，下面的配置是消息确认和消息回退的配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Component@Slf4j@Datapublic class MQCallback implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;    @Autowired    private RabbitTemplate rabbitTemplate;    private Event data;    @PostConstruct       &#x2F;&#x2F;此注解表明在rabbitTemplate注入之后，紧接着对rabbitTemplate进行一些初始化操作    public void init()&#123;        &#x2F;&#x2F;注入接口实现        rabbitTemplate.setConfirmCallback(this::confirm);           &#x2F;&#x2F;注入接口实现        rabbitTemplate.setReturnsCallback(this::returnedMessage);    &#125;    @TransactionalEventListener(phase &#x3D; TransactionPhase.AFTER_COMPLETION,fallbackExecution &#x3D; true)    public void listen(Event data)&#123;  &#x2F;&#x2F;此注解所标记的方法用来监听到发布的事件，就是生产者那里publisher所执行的方法    this.data &#x3D; data;    &#125;    @Override    public void confirm(CorrelationData correlationData, boolean ack, String errorMes) &#123;        CorrelationData correlationData1 &#x3D; Optional.ofNullable(correlationData).orElse(new CorrelationData());        if (ack)&#123;            log.info(&quot;发送成功&quot;,correlationData1.getId());        &#125;else &#123;           log.info(&quot;交换机未收到&#123;&#125;,发送失败原因&#123;&#125;&quot;,correlationData1.getId(),errorMes);            rabbitTemplate.convertAndSend(Config.EXCHANGE,Config.KEY_ONE,data.getData());        &#125;    &#125;    @Override    public void returnedMessage(ReturnedMessage returnedMessage) &#123;       log.error(&quot;回退消息&#123;&#125;&quot;,returnedMessage);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>confirm</strong>方法是交换机发生错误时的回调方法，以下是它所包含的三个参数：（刚重写完方法的参数名字应该不是我这个，可以自己修改，所代表的意思是一样的）</p><p>correlationData表示发送的消息的一些相关信息，包括消息的唯一ID，详细的可以点进去这个类进行查看</p><p>ack表示消息是否发送成功，true为成功，false为失败</p><p>errorMes表示错误的信息</p><p><strong>returnedMessage</strong>方法是队列发生错误时的回调方法，参数returnedMessage就是错误信息</p><p>6.还有一个事件类，这个和rabbitmq无关，只是用来监听生产者发送的消息</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@Getter@Setterpublic class Event&lt;T&gt; extends ApplicationEvent &#123;    private T data;    public Event(T data) &#123;        super(data);        this.data &#x3D; data;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装hexo</title>
    <link href="/2023/07/02/%E5%AE%89%E8%A3%85hexo/"/>
    <url>/2023/07/02/%E5%AE%89%E8%A3%85hexo/</url>
    
    <content type="html"><![CDATA[<p>要安装Hexo，您可以按照以下步骤进行操作：</p><ol><li><p><strong>安装 Node.js：</strong> Hexo 是基于 Node.js 的静态网站生成器，因此首先需要安装 Node.js。您可以从 Node.js 官方网站（<a href="https://nodejs.org/">https://nodejs.org</a>）下载适合您操作系统的版本，并按照安装向导进行安装。</p></li><li><p><strong>安装 Hexo：</strong> 在安装完 Node.js 后，打开命令行工具（终端或命令提示符），运行以下命令来全局安装 Hexo：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>创建 Hexo 网站：</strong> 创建一个新的 Hexo 网站，进入您想存储 Hexo 文件的目录，然后运行以下命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo init my-blog cd my-blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>安装依赖项：</strong> 进入 Hexo 网站目录后，运行以下命令来安装所需的依赖项：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><strong>推荐使用Fluid主题：</strong><br><strong>方式一：</strong><br>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--save</span> hexo-theme-fluid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>执行完此命令，在<strong>node_modules</strong>文件夹下有一个<strong>hexo-theme-fluid</strong>文件夹，<br>然后在博客目录下创建 <code>_config.fluid.yml</code>，将<strong>hexo-theme-fluid</strong>中的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。<br><strong>方式二：</strong><br>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p></li><li><p><strong>编写文章：</strong> 使用以下命令创建一篇新的文章：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;My First Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这将在 <code>source/_posts</code> 目录下创建一个 Markdown 文件，在其中编写您的文章。</p></li><li><p><strong>预览网站：</strong> 在编辑完文章后，可以使用以下命令在本地预览 Hexo 网站：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>关于页面的详细配置可以看<a href="">https://hexo.fluid-dev.com/docs/guide</a></p></li><li><p>hexo的官网是<a href="https://hexo.io/zh-cn/">Hexo</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo部署到github</title>
    <link href="/2023/07/02/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
    <url>/2023/07/02/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    
    <content type="html"><![CDATA[<p><strong>Hexo Theme Fluid的官方网址：</strong><a href="">https://hexo.fluid-dev.com/</a></p><p>打开自己博客文件夹的根目录下的配置文件 _config.yml，翻到最后，进行如下修改即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https:&#x2F;&#x2F;github自己的token@github.com&#x2F;github的username&#x2F;github的username.github.io  branch: gh-pages<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>&lt;github的username&gt;.github.io是你的github仓库。例如：zhangsan.github.io（github.io也是仓库名的一部分）</strong></p><p><strong>新的 token 设置网址：<a href="https://github.com/settings/tokens">Personal Access Tokens (Classic) (github.com)</a></strong></p><p>修改完配置文件 _config.yml 并保存后，回到 gitbash</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后进行部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>浏览 <code>&lt;github的username&gt;.github.io</code> 检查你的网站能否运作。例如：zhangsan.github.io</p><p>地址栏输入之后就能看到自己的博客了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker安装nginx</title>
    <link href="/2023/07/02/docker%E5%AE%89%E8%A3%85nginx/"/>
    <url>/2023/07/02/docker%E5%AE%89%E8%A3%85nginx/</url>
    
    <content type="html"><![CDATA[<h3 id="1-拉取-nginx-镜像"><a href="#1-拉取-nginx-镜像" class="headerlink" title="1. 拉取 nginx 镜像"></a>1. 拉取 nginx 镜像</h3><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none"># 拉取 nginx 镜像docker pull nginx           # 不加版本号默认下载 latest 版本，即 docker pull nginx:latest# 查看镜像docker images</code></pre></div></figure><h3 id="2-运行镜像（使用-nginx-latest-镜像创建容器）"><a href="#2-运行镜像（使用-nginx-latest-镜像创建容器）" class="headerlink" title="2. 运行镜像（使用 nginx:latest 镜像创建容器）"></a>2. 运行镜像（使用 nginx:latest 镜像创建容器）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;docker&#x2F;nginx&#x2F;conf # nginx 存放配置文件的目录 mkdir -p &#x2F;docker&#x2F;nginx&#x2F;logs # nginx 存放日志的目录 mkdir -p &#x2F;docker&#x2F;nginx&#x2F;html # nginx 启动网站目录（存放静态文件的目录）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>然后将 nginx 镜像中的部分文件拷贝到宿主机的挂载目录中</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 1. 先使用 nginx 镜像创建 nginx 容器，将文件拷贝出来先 docker run --name nginx -d -p 80:80 nginx # 2. 将容器中的 nginx.conf 文件拷贝到宿主机中 docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf # 3. 将容器中 conf.d 文件夹（包括里面的文件）拷贝到宿主机中 docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d # 4. 将容器中的 html 文件夹拷贝到宿主机中 docker cp nginx:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;docker&#x2F;nginx&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>停止刚刚运行的 nginx 容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 停止 nginx 容器 docker stop nginx # 删除 nginx 容器 docker rm nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>重新使用 nginx 镜像创建 nginx 容器，并挂载容器数据卷到宿主机目录中<br>    # 要执行的命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker run -p 80:80 --name nginx \-v &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \-v &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \-v &#x2F;docker&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \-d \--restart&#x3D;always \nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命令说明：</p><ul><li><code>-p 80:80</code> 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li><code>--name nginx</code> 命名启动的容器名字为 nginx</li><li><code>-v</code> 载文件或目录：前面是宿主机部分，后面是容器部分</li><li><code>-d</code> 表示后台启动容器</li><li><code>--restart=always</code> 重启模式，每次启动 docker 都会自动重启 nginx 容器。</li><li><code>nginx:latest</code> 表示使用该镜像创建容器</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
